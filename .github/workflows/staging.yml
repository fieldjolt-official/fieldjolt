name: Staging Deployment

on:
  push:
    branches: [staging]

env:
  PLANETSCALE_ORG: ${{ secrets.PLANETSCALE_ORG }}
  PLANETSCALE_DB: ${{ secrets.PLANETSCALE_DB }}
  PLANETSCALE_BRANCH: staging

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 22
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Setup PlanetScale CLI
        uses: planetscale/setup-pscale-action@v1

      - name: Debug role creation
        env:
          PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PLANETSCALE_SERVICE_TOKEN_ID }}
          PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PLANETSCALE_SERVICE_TOKEN }}
        run: |
          echo "Creating role..."
          ROLE_JSON=$(pscale role create "$PLANETSCALE_DB" "$PLANETSCALE_BRANCH" "test-role-${{ github.run_id }}" \
            --org "$PLANETSCALE_ORG" --format json)
          
          echo "Raw response:"
          echo "$ROLE_JSON" | jq '.'
          
          # Delete the test role
          ROLE_ID=$(echo "$ROLE_JSON" | jq -r '.id')
          pscale role delete "$PLANETSCALE_DB" "$PLANETSCALE_BRANCH" "$ROLE_ID" --org "$PLANETSCALE_ORG" --force

      - name: Get staging database credentials
        id: db-password
        env:
          PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PLANETSCALE_SERVICE_TOKEN_ID }}
          PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PLANETSCALE_SERVICE_TOKEN }}
        run: |
          echo "Creating database role..."
          ROLE_JSON=$(pscale role create "$PLANETSCALE_DB" "$PLANETSCALE_BRANCH" "staging-deploy-${{ github.run_id }}" \
            --org "$PLANETSCALE_ORG" --format json)
          
          echo "Raw response:"
          echo "$ROLE_JSON" | jq '.'
          
          # Parse credentials from response
          ROLE_ID=$(echo "$ROLE_JSON" | jq -r '.id')
          HOST=$(echo "$ROLE_JSON" | jq -r '.hostname')
          USERNAME=$(echo "$ROLE_JSON" | jq -r '.username')
          PASSWORD=$(echo "$ROLE_JSON" | jq -r '.password')
          
          echo "Parsed values:"
          echo "Role ID: $ROLE_ID"
          echo "Host: $HOST"
          echo "Username: $USERNAME"
          echo "Password length: ${#PASSWORD}"
          
          # Validate credentials
          if [ -z "$HOST" ] || [ "$HOST" = "null" ] || [ -z "$USERNAME" ] || [ "$USERNAME" = "null" ] || [ -z "$PASSWORD" ] || [ "$PASSWORD" = "null" ]; then
            echo "❌ Error: Failed to parse credentials"
            echo "Full response: $ROLE_JSON"
            exit 1
          fi
          
          # Build connection string
          DATABASE_URL="postgresql://${USERNAME}:${PASSWORD}@${HOST}/${PLANETSCALE_DB}?sslmode=require"
          
          # Mask sensitive data
          echo "::add-mask::$PASSWORD"
          echo "::add-mask::$DATABASE_URL"
          
          # Output for next steps
          echo "database_url=$DATABASE_URL" >> $GITHUB_OUTPUT
          echo "role_id=$ROLE_ID" >> $GITHUB_OUTPUT
          
          echo "✅ Database credentials created successfully"

      # Push schema changes (without --accept-data-loss for staging)
      - name: Push Prisma schema
        env:
          DATABASE_URL: ${{ steps.db-password.outputs.database_url }}
        run: |
          cd packages/db
          pnpm prisma generate
          
          # Try without --accept-data-loss first
          if ! pnpm prisma db push --skip-generate 2>&1 | tee push-output.txt; then
            echo "⚠️ Schema push failed"
            cat push-output.txt
            
            # Check if it's a data loss issue
            if grep -qi "data loss\|would result in data loss\|destructive" push-output.txt; then
              echo ""
              echo "❌ BLOCKING: Schema changes would cause data loss in staging."
              echo "Please review the changes carefully."
              echo ""
              echo "If you're sure this is safe, you can:"
              echo "1. Manually run: pnpm prisma db push --accept-data-loss"
              echo "2. Or add --accept-data-loss to the workflow for this deploy"
              exit 1
            else
              echo "❌ Schema push failed for unknown reason"
              exit 1
            fi
          fi
          
          echo "✅ Schema pushed successfully with no data loss"

      # Run tests
      - name: Run tests
        env:
          DATABASE_URL: ${{ steps.db-password.outputs.database_url }}
        run: pnpm test

      # Clean up the temporary role after deployment
      - name: Cleanup database role
        if: always()
        env:
          PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PLANETSCALE_SERVICE_TOKEN_ID }}
          PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PLANETSCALE_SERVICE_TOKEN }}
        run: |
          ROLE_ID="${{ steps.db-password.outputs.role_id }}"
          
          if [ -n "$ROLE_ID" ]; then
            echo "Cleaning up role: $ROLE_ID"
            pscale role delete "$PLANETSCALE_DB" "$PLANETSCALE_BRANCH" "$ROLE_ID" \
              --org "$PLANETSCALE_ORG" --force || true
            echo "✅ Role cleaned up"
          fi

      # # Deploy to Vercel (staging)
      # - name: Deploy to Vercel
      #   env:
      #     VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
      #     DATABASE_URL: ${{ steps.db-password.outputs.database_url }}
      #   run: |
      #     npm install -g vercel@latest
      #     vercel deploy --prod \
      #       --token=$VERCEL_TOKEN \
      #       --build-env DATABASE_URL="$DATABASE_URL" \
      #       --env DATABASE_URL="$DATABASE_URL" \
      #       --yes

      # # Deploy to Cloudflare (staging)
      # - name: Deploy API to Cloudflare
      #   env:
      #     CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      #     DATABASE_URL: ${{ steps.db-password.outputs.database_url }}
      #   run: |
      #     cd apps/api
      #     npx wrangler deploy --env staging \
      #       --var DATABASE_URL:"$DATABASE_URL"