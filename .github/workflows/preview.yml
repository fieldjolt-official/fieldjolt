name: Preview Deployment

on:
  pull_request:
    branches: [staging]
    types: [opened, synchronize, reopened]

env:
  PSCALE_ORG: ${{ secrets.PSCALE_ORG_NAME }}
  PSCALE_DB: ${{ secrets.PSCALE_DATABASE_NAME }}

jobs:
  preview:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      # Setup PlanetScale CLI
      - name: Setup PlanetScale CLI
        uses: planetscale/setup-pscale-action@v1

      # Sanitize branch name for PlanetScale
      - name: Create PlanetScale branch name
        id: branch-name
        run: |
          # Convert feature/my-feature to feature-my-feature (lowercase, alphanumeric + hyphens only)
          BRANCH_NAME=$(echo "${{ github.head_ref }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
          echo "name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "üì¶ PlanetScale branch name: $BRANCH_NAME"

      # Create or reuse PlanetScale branch
      - name: Create PlanetScale branch
        id: ps-branch
        env:
          PLANETSCALE_SERVICE_TOKEN_ID: ${{ secrets.PLANETSCALE_SERVICE_TOKEN_ID }}
          PLANETSCALE_SERVICE_TOKEN: ${{ secrets.PLANETSCALE_SERVICE_TOKEN }}
        run: |
          BRANCH="${{ steps.branch-name.outputs.name }}"
          
          # Check if branch exists
          if pscale branch show "$PSCALE_DB" "$BRANCH" --org "$PSCALE_ORG" 2>/dev/null; then
            echo "‚úÖ Branch already exists"
          else
            echo "üîÑ Creating new branch from staging..."
            pscale branch create "$PSCALE_DB" "$BRANCH" --from staging --org "$PSCALE_ORG"
            
            # Wait for branch to be ready
            echo "‚è≥ Waiting for branch to be ready..."
            for i in {1..30}; do
              STATUS=$(pscale branch show "$PSCALE_DB" "$BRANCH" --org "$PSCALE_ORG" --format json | jq -r '.ready')
              if [ "$STATUS" = "true" ]; then
                echo "‚úÖ Branch is ready!"
                break
              fi
              echo "Waiting... ($i/30)"
              sleep 10
            done
          fi

      # Create connection password for the branch
      - name: Create database password
        id: db-password
        env:
          PSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
          PSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
        run: |
          BRANCH="${{ steps.branch-name.outputs.name }}"
          
          # Create a password (returns JSON with connection details)
          PASSWORD_JSON=$(pscale password create "$PSCALE_DB" "$BRANCH" "preview-${{ github.run_id }}" \
            --org "$PSCALE_ORG" --format json --role admin)
          
          # Extract connection details
          HOST=$(echo "$PASSWORD_JSON" | jq -r '.hostname')
          USERNAME=$(echo "$PASSWORD_JSON" | jq -r '.username')
          PASSWORD=$(echo "$PASSWORD_JSON" | jq -r '.plain_text')
          
          # Build PostgreSQL connection string
          DATABASE_URL="postgresql://${USERNAME}:${PASSWORD}@${HOST}/${PSCALE_DB}?sslmode=require"
          
          # Mask the password in logs
          echo "::add-mask::$PASSWORD"
          echo "::add-mask::$DATABASE_URL"
          
          # Output for next steps
          echo "database_url=$DATABASE_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Database credentials created"

      # Push Prisma schema to PlanetScale branch
      - name: Push Prisma schema
        env:
          DATABASE_URL: ${{ steps.db-password.outputs.database_url }}
        run: |
          cd packages/db
          pnpm prisma generate
          pnpm prisma db push --skip-generate --accept-data-loss
          echo "‚úÖ Schema pushed successfully"

      # Deploy Next.js app to Vercel
      - name: Deploy to Vercel
        id: vercel
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          DATABASE_URL: ${{ steps.db-password.outputs.database_url }}
        run: |
          # Install Vercel CLI
          npm install -g vercel@latest
          
          # Deploy to preview
          DEPLOYMENT_URL=$(vercel deploy \
            --token=$VERCEL_TOKEN \
            --build-env DATABASE_URL="$DATABASE_URL" \
            --env DATABASE_URL="$DATABASE_URL" \
            --yes)
          
          echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Deployed to Vercel: $DEPLOYMENT_URL"

      # Deploy Cloudflare Worker (API)
      - name: Deploy API to Cloudflare
        id: cloudflare
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          DATABASE_URL: ${{ steps.db-password.outputs.database_url }}
        run: |
          cd apps/api
          
          # Deploy to Cloudflare Workers with environment variable
          npx wrangler deploy --env preview \
            --var DATABASE_URL:"$DATABASE_URL"
          
          API_URL="https://api-${{ steps.branch-name.outputs.name }}.fieldjolt.workers.dev"
          echo "url=$API_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Deployed to Cloudflare: $API_URL"

      # Comment on PR with deployment links
      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const comment = `## üöÄ Preview Deployment Ready!
            
            | Service | URL |
            |---------|-----|
            | üåê **App** | ${{ steps.vercel.outputs.url }} |
            | ‚ö° **API** | ${{ steps.cloudflare.outputs.url }} |
            | üóÑÔ∏è **Database** | PlanetScale branch \`${{ steps.branch-name.outputs.name }}\` |
            
            ### Next Steps:
            - Test your changes in the preview environment
            - When ready, request review to merge into staging
            
            ---
            *Preview will be automatically cleaned up when PR is closed*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Cleanup when PR is closed
  cleanup:
    runs-on: ubuntu-latest
    if: github.event.action == 'closed'
    
    steps:
      - name: Setup PlanetScale CLI
        uses: planetscale/setup-pscale-action@v1

      - name: Delete PlanetScale branch
        env:
          PSCALE_SERVICE_TOKEN_ID: ${{ secrets.PSCALE_SERVICE_TOKEN_ID }}
          PSCALE_SERVICE_TOKEN: ${{ secrets.PSCALE_SERVICE_TOKEN }}
        run: |
          BRANCH_NAME=$(echo "${{ github.head_ref }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
          
          pscale branch delete "${{ secrets.PSCALE_DATABASE_NAME }}" "$BRANCH_NAME" \
            --org "${{ secrets.PSCALE_ORG_NAME }}" --force || true
          
          echo "‚úÖ Branch $BRANCH_NAME deleted"